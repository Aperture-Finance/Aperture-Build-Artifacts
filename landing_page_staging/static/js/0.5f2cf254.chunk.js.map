{"version":3,"sources":["components/Offering/index.js","components/Offering/OfferingList.js","../../src/index.tsx","../node_modules/react-hook-inview/dist/esm/useObserver.js","../node_modules/react-hook-inview/dist/esm/useInView.js"],"names":["Offering","useApp","language","width","text","textContext","offering","React","useState","view","setView","useInView","threshold","ref","isVisible","useEffect","setTimeout","id","className","title","transitionDuration","delay","visible","list","map","l","i","OfferingList","props","header","body","image","color","container","item","xs","md","style","src","alt","maxIsVisible","setMaxIsVisible","animated","WrapperTag","ChildTag","count","timeout","clearTimeout","increment","childClassName","transition","transform","opacity","useObserver","callback","root","rootMargin","externalState","target","useRef","observer","setTarget","useCallback","node","current","unobserve","disconnect","IntersectionObserver","observe","unobserveOnEnter","onEnter","onLeave","inView","entry","state","setState","thresholds","some","t","intersectionRatio","isIntersecting"],"mappings":"qQAWe,SAASA,IAAY,IAAD,EAENC,cAApBC,EAF0B,EAE1BA,SAAUC,EAFgB,EAEhBA,MACXC,EAAOC,IAAYH,GAAUI,SAHF,EAKVC,IAAMC,UAAS,GALL,mBAK3BC,EAL2B,KAKrBC,EALqB,OAMRC,YAAU,CACjCC,UAAWT,EAAQ,IAAM,GAAM,IAPA,mBAM1BU,EAN0B,KAMrBC,EANqB,KAqBlC,OAVCP,IAAMQ,WAAU,WACXZ,EAAQ,IACXa,YAAW,WACEN,IAAZI,KACE,KAESJ,IAAZI,KAEC,CAACA,EAAWX,IAGf,qBAAKU,IAAKA,EAAKI,GAAG,WAAlB,SACC,sBAAKC,UAAU,wBAAf,UACC,mBAAGA,UAAU,aAAb,SAA2Bd,EAAKe,QAChC,cAAC,IAAD,CAAYC,mBAAoB,IAAMC,MAAO,IAAKC,QAASb,EAA3D,SAEEL,EAAKmB,KAAKC,KAAI,SAACC,EAAEC,GAAH,OACb,cAAC,UAAD,CAAcvB,MAAOA,EAAesB,EAAGA,GAANC,e,iCCvCxC,wEAGe,SAASC,EAAaC,GAAQ,IAAD,EAEJA,EAAMH,EAArCI,EAFmC,EAEnCA,OAAQC,EAF2B,EAE3BA,KAAMC,EAFqB,EAErBA,MAAOC,EAFc,EAEdA,MAE7B,OACC,eAAC,IAAD,CAAMC,WAAS,EAACf,UAAU,gBAA1B,UACC,eAAC,IAAD,CAAMA,UAAU,OAAOgB,MAAI,EAACC,GAAI,GAAIC,GAAI,EAAxC,UACC,oBAAIC,MAAO,CAACL,MAAOA,GAAnB,SAA4BH,IAC3BD,EAAMzB,MAAQ,KAAO,4BAAI2B,OAE3B,eAAC,IAAD,CAAMZ,UAAU,OAAOgB,MAAI,EAACC,GAAI,GAAIC,GAAI,EAAxC,UACC,qBAAKE,IAAKP,EAAOQ,IAAKV,IACrBD,EAAMzB,MAAQ,KAAO,4BAAI2B,Y,yDCDX,SAACF,G,MAChB,EAAwCpB,mBAAxC,GAAOgC,EAAP,KAAqBC,EAArB,KAEMpB,EAAQO,SAAd,GACMc,EAAQ,SAAGd,EAAH,aACRR,EAAqBQ,sBAF3B,IAGMN,EAAU,qBAAOM,EAAP,SAA8CA,EAH9D,QAIMe,EAAaf,cAJnB,MAKMgB,EAAWhB,YALjB,MAsCA,OA/BAb,qBAAU,WACN,IAAI8B,EAAQtC,mBAAqBqB,EAAjC,UAMA,GALA,IAEIiB,KAGAA,GAAJ,EAA2B,CAEvB,IAAMC,EAAU9B,YAAW,WACnBY,EAAJ,YAAsBA,iBAD1B,GAIA,OAAO,kBAAMmB,aAAN,IAIX,IAAMC,EAAYH,OAAlB,EACMC,EAAU9B,YAAW,WACvByB,EAAgBD,EAAhBC,KADJ,GAIA,OAAO,kBAAMM,aAAN,MACR,CACCxC,mBAAqBqB,EADtB,gBAvBHb,IAgCI,qBAAYG,UAAWU,EAAMV,WACxBwB,EAAW,iBAAmBd,EAAnB,UAAmC,cAC3C,OACI,qBACIV,UAAWU,EAAMqB,eACjBZ,MAAO,CACPa,WAAY,WAAF,qBADH,KAEPC,UAAWX,WAFJ,mBAGPY,QAASZ,MAAuB,IANxC,MAYCZ,EAfb,Y,8FC9BWyB,EAlBK,SAACC,GAAuE,6DAA3B,GAAhCC,EAA2D,EAA3DA,KAAMC,EAAqD,EAArDA,WAAY5C,EAAyC,EAAzCA,UAAkB6C,EAAuB,uDAAP,GAC3EC,EAASC,iBAAO,MAChBC,EAAWD,iBAAO,MAClBE,EAAYC,uBAAY,SAACC,GACvBL,EAAOM,SAAWJ,EAASI,UAC3BJ,EAASI,QAAQC,UAAUP,EAAOM,SAClCJ,EAASI,QAAQE,aACjBN,EAASI,QAAU,MAEnBD,IACAH,EAASI,QAAU,IAAIG,qBAAqBb,EAAU,CAAEC,OAAMC,aAAY5C,cAC1EgD,EAASI,QAAQI,QAAQL,GACzBL,EAAOM,QAAUD,KATI,CAYzBL,EAAQH,EAAMC,EAAY5C,GAZD,mBAYe6C,KAC5C,OAAOI,GCmBIlD,EAnCG,WAA0G,6DAA3B,GAA5E4C,EAAuG,EAAvGA,KAAMC,EAAiG,EAAjGA,WAAY5C,EAAqF,EAArFA,UAAWyD,EAA0E,EAA1EA,iBAAkBX,EAAwD,EAAxDA,OAAQY,EAAgD,EAAhDA,QAASC,EAAuC,EAAvCA,QAAgBd,EAAuB,uDAAP,GAAO,EAC9FjD,mBAAS,CAC/BgE,QAAQ,EACRC,MAAO,KACPb,SAAU,OAJ0G,mBACjHc,EADiH,KAC1GC,EAD0G,KAMlHrB,EAAWQ,uBAAY,WAAUF,GAAa,IAArBa,EAAqB,oBAE1CD,EADcZ,EAASgB,WAAWC,MAAK,SAACC,GAAD,OAAOL,EAAMM,mBAAqBD,MACjDL,EAAMO,eACpCL,EAAS,CACLH,SACAC,QACAb,aAGAY,GAAUH,IACVT,EAASK,UAAUQ,EAAMf,QACzBE,EAASM,cAGTM,EACY,OAAZF,QAAgC,IAAZA,GAA8BA,EAAQG,EAAOb,GAGrD,OAAZW,QAAgC,IAAZA,GAA8BA,EAAQE,EAAOb,KAEtE,CAACU,EAASC,EAASF,IAChBR,EAAYR,EAAYC,EAAU,CAAEC,OAAMC,aAAY5C,aAA/B,CAA6CyD,GAA7C,mBAAkEZ,KAM/F,OAJA1C,qBAAU,YACS,OAAX2C,QAA8B,IAAXA,OAAoB,EAASA,EAAOM,UACvDH,EAAUH,EAAOM,WACtB,CAACN,EAAQG,IACL,CAACA,EAAWa,EAAMF,OAAQE,EAAMD,MAAOC,EAAMd","file":"static/js/0.5f2cf254.chunk.js","sourcesContent":["import React from 'react'\nimport { useApp } from '../../context/Context';\nimport textContext from '../../textContext';\n\n// Hook for checking viewport + animation package\nimport { useInView } from 'react-hook-inview';\nimport SmoothList from 'react-smooth-list';\n\n// Comps\nimport OfferingList from './OfferingList';\n\nexport default function Offering() {\n\n\tconst { language, width } = useApp();\n  const text = textContext[language].offering;\n\n\tconst [view, setView] = React.useState(false);\n  const [ref, isVisible] = useInView({\n    threshold: width > 900 ? 0.5 : 0,\n  })\n\n  // Trigger setView on viewport enter\n  React.useEffect(() => {\n  \tif (width < 900) {\n  \t\tsetTimeout(() => {\n  \t\t\tisVisible ? setView(true) : setView(false)\n  \t\t}, 500)\n  \t} else {\n  \t\tisVisible ? setView(true) : setView(false)\n  \t}\n  }, [isVisible, width])\n\n\treturn (\n\t\t<div ref={ref} id=\"offering\">\n\t\t\t<div className=\"padding textContainer\">\n\t\t\t\t<p className=\"textHeader\">{text.title}</p>\n\t\t\t\t<SmoothList transitionDuration={1000} delay={100} visible={view}>\n\t\t\t\t\t{\n\t\t\t\t\t\ttext.list.map((l,i) => (\n\t\t\t\t\t\t\t<OfferingList width={width} key={i} l={l} />\n\t\t\t\t\t\t))\n\t\t\t\t\t}\n\t\t\t\t</SmoothList>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n","import React from 'react'\nimport Grid from '@mui/material/Grid';\n\nexport default function OfferingList(props) {\n\n\tconst { header, body, image, color } = props.l;\n\n\treturn (\n\t\t<Grid container className=\"offeringClass\">\n\t\t\t<Grid className=\"grid\" item xs={12} md={6}>\n\t\t\t\t<h2 style={{color: color}}>{header}</h2>\n\t\t\t\t{props.width > 900 && <p>{body}</p>}\n\t\t\t</Grid>\n\t\t\t<Grid className=\"grid\" item xs={12} md={6}>\n\t\t\t\t<img src={image} alt={header} />\n\t\t\t\t{props.width < 900 && <p>{body}</p>}\n\t\t\t</Grid>\n\t\t</Grid>\n\t)\n}","import React, { JSXElementConstructor, PropsWithChildren, useEffect, useState } from \"react\";\n  \ninterface Props {\n    transitionDuration?: number;\n    delay?: number;\n    wrapperTag?: JSXElementConstructor<any>;\n    childTag?: JSXElementConstructor<any>;\n    className?: string;\n    childClassName?: string;\n    visible?: boolean;\n    animated?: boolean;\n    onComplete?: () => any;\n}\n  \nconst SmoothList = (props: PropsWithChildren<Props>) => {\n    const [maxIsVisible, setMaxIsVisible] = useState(0);\n\n    const delay = props.delay || 50,\n          animated = props.animated ?? true,\n          transitionDuration = props.transitionDuration || 400,\n          visible = typeof props.visible === \"undefined\" ? true : props.visible,\n          WrapperTag = props.wrapperTag || \"div\",\n          ChildTag = props.childTag || \"div\";\n  \n    useEffect(() => {\n        let count = React.Children.count(props.children);\n        if (!visible) {\n            // Animate all children out\n            count = 0;\n        }\n\n        if (count == maxIsVisible) {\n            // We're done updating maxVisible, notify when animation is done\n            const timeout = setTimeout(() => {\n                if (props.onComplete) props.onComplete();\n            }, transitionDuration);\n            \n            return () => clearTimeout(timeout)\n        }\n\n        // Move maxIsVisible toward count\n        const increment = count > maxIsVisible ? 1 : -1;\n        const timeout = setTimeout(() => {\n            setMaxIsVisible(maxIsVisible + increment);\n        }, delay);\n        \n        return () => clearTimeout(timeout)\n    }, [\n        React.Children.count(props.children),\n        delay,\n        maxIsVisible,\n        visible,\n        transitionDuration,\n    ])\n  \n    return (\n        <WrapperTag className={props.className}>\n            {animated ? React.Children.map(props.children, (child, i) => {\n                return (\n                    <ChildTag\n                        className={props.childClassName}\n                        style={{\n                        transition: `opacity ${transitionDuration}ms, transform ${transitionDuration}ms`,\n                        transform: maxIsVisible > i ? \"none\" : \"translateY(20px)\",\n                        opacity: maxIsVisible > i ? 1 : 0,\n                        }}\n                    >\n                        {child}\n                    </ChildTag>\n                )\n            }) : props.children}\n        </WrapperTag>\n    )\n}\n\nexport default SmoothList;","import { useRef, useCallback, } from \"react\";\n/**\n * useObserver\n * @param callback IntersectionObserverCallback\n * @param options IntersectionObserverInit\n * @param externalState React.ComponentState[]\n */\nconst useObserver = (callback, { root, rootMargin, threshold } = {}, externalState = []) => {\n    const target = useRef(null);\n    const observer = useRef(null);\n    const setTarget = useCallback((node) => {\n        if (target.current && observer.current) {\n            observer.current.unobserve(target.current);\n            observer.current.disconnect();\n            observer.current = null;\n        }\n        if (node) {\n            observer.current = new IntersectionObserver(callback, { root, rootMargin, threshold });\n            observer.current.observe(node);\n            target.current = node;\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [target, root, rootMargin, threshold, ...externalState]);\n    return setTarget;\n};\nexport default useObserver;\n","import { useEffect, useState, useCallback, } from \"react\";\nimport useObserver from \"./useObserver\";\n/**\n * useInView\n * @param options IntersectionObserverInit\n * @param externalState React.ComponentState[]\n */\nconst useInView = ({ root, rootMargin, threshold, unobserveOnEnter, target, onEnter, onLeave } = {}, externalState = []) => {\n    const [state, setState] = useState({\n        inView: false,\n        entry: null,\n        observer: null,\n    });\n    const callback = useCallback(([entry], observer) => {\n        const inThreshold = observer.thresholds.some((t) => entry.intersectionRatio >= t);\n        const inView = inThreshold && entry.isIntersecting;\n        setState({\n            inView,\n            entry,\n            observer,\n        });\n        // unobserveOnEnter\n        if (inView && unobserveOnEnter) {\n            observer.unobserve(entry.target);\n            observer.disconnect();\n        }\n        // Legacy callbacks\n        if (inView) {\n            onEnter === null || onEnter === void 0 ? void 0 : onEnter(entry, observer);\n        }\n        else {\n            onLeave === null || onLeave === void 0 ? void 0 : onLeave(entry, observer);\n        }\n    }, [onEnter, onLeave, unobserveOnEnter]);\n    const setTarget = useObserver(callback, { root, rootMargin, threshold }, [unobserveOnEnter, ...externalState]);\n    // Legacy 'target' option\n    useEffect(() => {\n        if (target === null || target === void 0 ? void 0 : target.current)\n            setTarget(target.current);\n    }, [target, setTarget]);\n    return [setTarget, state.inView, state.entry, state.observer];\n};\nexport default useInView;\n"],"sourceRoot":""}